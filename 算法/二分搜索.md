# 二分搜索
二分搜索，简单来讲就是如何从一个有序数列中快速得到某个值的位置。

当数列**没有重复**元素的时候，即为[寻找一个数](#寻找一个数)

当数列**有重复**元素的时候，即为[寻找边界](#寻找边界)

# 寻找一个数
基本的二分搜索，给定一个**没有重复元素的有序数列**，查找某个值的位置

## 思路分析
网上有很多关于二分法细节的文章，我看了一圈下来，认为两边都是闭区间的思路是好理解的，也是好记忆的，并且能够用图记住细节问题，所以本文整体都采用了左闭右开这个思路。

假设在[begin，end]范围内搜索某个元素 v，mid =（begin + end）/ 2

1. 如果v < m，去[begin ， mid-1]范围内二分搜索
2. 如果v > m，去[mid + 1， end]范围内二分搜索
3. 如果v == m ，直接返回 mid

end指的是数组的长度。
![](二分搜索_files/1.jpg)

## 实例
![](二分搜索_files/4.jpg)

![](二分搜索_files/2.jpg)

## 实现代码
``` c++
  int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
			 //不可使用int mid = left/2 + right/2;取整原因，可能会导致丢失数值
            int mid = left + (right - left) /2;  实现中位数的计算，由于向下取整操作，
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid - 1;
            }else if(nums[mid] < target){
                left = mid + 1;
            }
        }
        return -1;
    }
```

## 适用场景
[有序数列搜索问题](../适用场景/搜索问题.md#输出元素位置)

## 试题
[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

关于最后返回值的一些思考：

当使用```while(left <= right)```作为循环入口的时候，循环最后一次执行的情况必定是```left==right```的情况，可以根据这一点，分析一些具体场景在返回值时的选项，到底返回left还是right还是mid的值


# 寻找边界

// TODO:未完全写完这篇解析

给定一个**含有重复元素的有序数列**，查找某个值的左边界或者右边界

## 思路分析

假设在[begin，end]范围内搜索某个元素 v，mid =（begin + end）/ 2

1. 如果v < m，去[begin ， mid-1]范围内二分搜索
2. 如果v > m，去[mid + 1， end]范围内二分搜索
3. 如果v == m ，直接返回 mid

end指的是数组的长度。
![](二分搜索_files/1.jpg)

## 实例
![](二分搜索_files/4.jpg)

![](二分搜索_files/2.jpg)

## 实现代码
``` c++
  int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
			 //不可使用int mid = left/2 + right/2;取整原因，可能会导致丢失数值
            int mid = left + (right - left) /2;  实现中位数的计算，由于向下取整操作，
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid - 1;
            }else if(nums[mid] < target){
                left = mid + 1;
            }
        }
        return -1;
    }
```

## 适用场景
[有序数列搜索问题](../适用场景/搜索问题.md#输出元素位置)

## 试题
[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)