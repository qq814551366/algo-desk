一、前沿概念：[树](/树.md)、[二叉树](../名词/二叉树.md)

> 转载至：[蓝海人：二叉树、前序遍历、中序遍历、后序遍历](https://www.cnblogs.com/lanhaicode/p/10358736.html)

# 三、二叉树的遍历（前序\中序\后序遍历）

二叉树的遍历是指不重复地访问二叉树中所有结点，主要指非空二叉树，对于空二叉树则结束返回，二叉树的遍历主要包括前序遍历、中序遍历、后序遍历

## 前序遍历
首先访问根结点，然后遍历左子树，最后遍历右子树（根->左->右）

顺序：访问根节点->前序遍历左子树->前序遍历右子树
``` c++
/* 以递归方式 前序遍历二叉树 */
void PreOrderTraverse(BiTree t, int level)
{
    if (t == NULL)
    {
        return ;
    }
    printf("data = %c level = %d\n ", t->data, level);
    PreOrderTraverse(t->lchild, level + 1);
    PreOrderTraverse(t->rchild, level + 1);
}
```

## 中序遍历
首先遍历左子树，然后访问根节点，最后遍历右子树（左->根->右）
顺序：中序遍历左子树->访问根节点->中序遍历右子树
``` c++
/* 以递归方式 中序遍历二叉树 */
void PreOrderTraverse(BiTree t, int level)
{
    if (t == NULL)
    {
        return ;
    }
    PreOrderTraverse(t->lchild, level + 1);
    printf("data = %c level = %d\n ", t->data, level);
    PreOrderTraverse(t->rchild, level + 1);
}
```
## 后序遍历
首先遍历左子树，然后遍历右子树，最后访问根节点（左->右->根）

顺序：后序遍历左子树->后序遍历右子树->访问根节点

``` c++
/* 以递归方式 后序遍历二叉树 */
void PreOrderTraverse(BiTree t, int level)
{
    if (t == NULL)
    {
        return ;
    }
    PreOrderTraverse(t->lchild, level + 1);
    PreOrderTraverse(t->rchild, level + 1);
    printf("data = %c level = %d\n ", t->data, level);
}
```
 从上面可以看出，三种遍历方式极其相似，只是语句 ```printf("data = %c level = %d\n ", t->data, level);```的位置发生了变化